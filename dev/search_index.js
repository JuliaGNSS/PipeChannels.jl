var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#PipeChannel-Type","page":"API Reference","title":"PipeChannel Type","text":"","category":"section"},{"location":"api/#Channel-Operations","page":"API Reference","title":"Channel Operations","text":"","category":"section"},{"location":"api/#Query-Functions","page":"API Reference","title":"Query Functions","text":"","category":"section"},{"location":"api/#Iteration","page":"API Reference","title":"Iteration","text":"PipeChannel supports Julia's iteration protocol. You can iterate over values until the channel is closed and empty:\n\nch = PipeChannel{Int}(16)\nfor i in 1:5\n    put!(ch, i)\nend\nclose(ch)\n\nfor value in ch\n    println(value)\nend\n# Output: 1, 2, 3, 4, 5","category":"section"},{"location":"api/#PipeChannels.PipeChannel","page":"API Reference","title":"PipeChannels.PipeChannel","text":"PipeChannel{T}\n\nA lock-free single-producer single-consumer channel using a ring buffer.\n\nThis implementation uses atomic operations for the head and tail indices, allowing one thread to write and another to read without any locks. This eliminates allocations in the hot path that would otherwise occur with Julia's Channel type.\n\nThe API matches Julia's Channel:\n\nput! blocks when full, throws InvalidStateException when closed\ntake! blocks when empty, throws InvalidStateException when closed and empty\nIteration works with for x in ch syntax\nbind connects a task to the channel for error propagation\n\nType Parameters\n\nT: Element type stored in the channel\n\nFields\n\nbuffer::Vector{T}: Pre-allocated storage\ncapacity::Int: Maximum number of elements (one slot reserved for full/empty detection)\nhead::Threads.Atomic{Int}: Write position (modified only by producer)\ntail::Threads.Atomic{Int}: Read position (modified only by consumer)\n\nThread Safety\n\nExactly ONE producer thread may call put!\nExactly ONE consumer thread may call take!\nMultiple producers or consumers will cause data races\n\nExamples\n\nch = PipeChannel{Int}(16)\n\n# Producer thread\nput!(ch, 42)\nclose(ch)\n\n# Consumer thread\nvalue = take!(ch)  # Returns 42\ntake!(ch)  # Throws InvalidStateException (closed and empty)\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.put!-Union{Tuple{T}, Tuple{PipeChannel{T}, T}} where T","page":"API Reference","title":"Base.put!","text":"put!(ch::PipeChannel{T}, value::T)\n\nAdd an element to the buffer. Blocks if the buffer is full.\n\nThrows\n\nInvalidStateException: If the channel is closed\nThe bound task's exception if the task failed\n\nThread Safety\n\nMust only be called from a single producer thread.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.take!-Tuple{PipeChannel}","page":"API Reference","title":"Base.take!","text":"take!(ch::PipeChannel{T}) -> T\n\nRemove and return an element from the buffer. Blocks if the buffer is empty.\n\nThrows\n\nInvalidStateException: If the channel is closed and empty\nThe bound task's exception if the task failed\n\nThread Safety\n\nMust only be called from a single consumer thread.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.close-Tuple{PipeChannel}","page":"API Reference","title":"Base.close","text":"close(ch::PipeChannel, excp::Exception=closed_exception())\n\nClose the channel. After closing:\n\nput! will throw InvalidStateException (or the bound task's exception)\ntake! will return remaining elements, then throw InvalidStateException (or the bound task's exception)\n\nIf excp is provided, it will be stored and thrown on subsequent operations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.bind-Tuple{PipeChannel, Task}","page":"API Reference","title":"Base.bind","text":"bind(ch::PipeChannel, task::Task)\n\nBind a task to the channel. When the task terminates:\n\nThe channel is automatically closed\nIf the task failed with an exception, that exception will be thrown on subsequent put! or take! operations\n\nThis is useful for propagating errors from producer/consumer tasks.\n\nExamples\n\nch = PipeChannel{Int}(16)\ntask = @async begin\n    for i in 1:10\n        put!(ch, i)\n    end\n    close(ch)\nend\nbind(ch, task)\n\n# If task fails, the exception propagates to consumers\nfor x in ch\n    println(x)\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isopen-Tuple{PipeChannel}","page":"API Reference","title":"Base.isopen","text":"isopen(ch::PipeChannel) -> Bool\n\nCheck if the channel is still open for operations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isready-Tuple{PipeChannel}","page":"API Reference","title":"Base.isready","text":"isready(ch::PipeChannel) -> Bool\n\nCheck if data is available to read (i.e., buffer is not empty).\n\nThis is the opposite of isempty and matches the Channel API where isready(ch) returns true when take! would not block.\n\nThread Safety Note\n\nSame as isempty: only guaranteed accurate from the consumer thread. May return false even when data is available if called from the producer thread (false negative is safe - just causes unnecessary waiting).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isempty-Tuple{PipeChannel}","page":"API Reference","title":"Base.isempty","text":"isempty(ch::PipeChannel) -> Bool\n\nCheck if the buffer is empty.\n\nThread Safety Note\n\nThis function is only guaranteed to be accurate when called from the consumer thread.\n\nThe result can be a false positive (reports empty when not empty) if called from the producer thread, because the producer may have advanced head after we read it but before we compare. This is safe - it just means the consumer might unnecessarily wait.\n\nHowever, if the consumer calls this and it returns false, it is guaranteed that there is data to read, because only the consumer advances tail and only the producer advances head (which can only add more data, not remove it).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isfull-Tuple{PipeChannel}","page":"API Reference","title":"Base.isfull","text":"isfull(ch::PipeChannel) -> Bool\n\nCheck if the buffer is full.\n\nThread Safety Note\n\nThis function is only guaranteed to be accurate when called from the producer thread.\n\nThe result can be a false positive (reports full when not full) if called from the consumer thread, because the consumer may have advanced tail after we read it but before we compare. This is safe - it just means the producer might unnecessarily wait.\n\nHowever, if the producer calls this and it returns false, it is guaranteed that there is space to write, because only the producer advances head and only the consumer advances tail (which can only create more space, not less).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.n_avail-Tuple{PipeChannel}","page":"API Reference","title":"Base.n_avail","text":"n_avail(ch::PipeChannel) -> Int\n\nReturn the number of elements available to read.\n\nThread Safety Note\n\nThis is an approximation that may be slightly stale. The actual count may be higher (if the producer added items after we read head) but never lower (the consumer is the only one who can remove items by advancing tail).\n\nMost accurate when called from the consumer thread.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.wait-Tuple{PipeChannel}","page":"API Reference","title":"Base.wait","text":"wait(ch::PipeChannel)\n\nBlock until data is available in the buffer or the channel is closed.\n\nUnlike take!, this does not consume the data - it just waits until isready(ch) would return true, or throws if the channel is closed and empty.\n\nThrows\n\nInvalidStateException: If the channel is closed and empty\nThe bound task's exception if the task failed\n\nThread Safety\n\nShould only be called from the consumer thread.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.iterate-Union{Tuple{T}, Tuple{PipeChannel{T}, Any}} where T","page":"API Reference","title":"Base.iterate","text":"iterate(ch::PipeChannel{T}, state=nothing)\n\nIterate over values in the channel until it's closed and empty. Catches InvalidStateException to cleanly end iteration. If a bound task failed, the TaskFailedException is propagated.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.eltype-Union{Tuple{Type{PipeChannel{T}}}, Tuple{T}} where T","page":"API Reference","title":"Base.eltype","text":"eltype(::Type{PipeChannel{T}}) where T\n\nReturns the element type T of the PipeChannel{T}.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.IteratorSize-Tuple{Type{<:PipeChannel}}","page":"API Reference","title":"Base.IteratorSize","text":"IteratorSize(::Type{<:PipeChannel})\n\nReturns Base.SizeUnknown() since the number of elements in a PipeChannel cannot be determined in advance (depends on when the channel is closed).\n\n\n\n\n\n","category":"method"},{"location":"#PipeChannels.jl","page":"Home","title":"PipeChannels.jl","text":"A lock-free single-producer single-consumer (SPSC) channel for Julia.","category":"section"},{"location":"#Why-PipeChannels?","page":"Home","title":"Why PipeChannels?","text":"Julia's built-in Channel type is excellent for general-purpose concurrent programming, but it allocates memory on every put! and take! operation due to its task scheduling and condition variable infrastructure. This is usually fine, but in real-time applications where consistent latency matters (such as SDR signal processing, audio processing, or high-frequency trading), these allocations can trigger garbage collection pauses at unpredictable times.\n\nPipeChannel solves this by using a lock-free ring buffer with atomic operations. The trade-off is that it only supports exactly one producer thread and one consumer thread - but for many streaming pipelines, this is exactly the pattern you need.","category":"section"},{"location":"#Performance","page":"Home","title":"Performance","text":"Benchmarks show:\n\n4-6x faster throughput compared to Channel\n99.8% reduction in allocations\nZero allocations in the hot path (put!/take!)","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"PipeChannels\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"The API matches Julia's Channel:\n\nusing PipeChannels\n\n# Create a channel with capacity 16\nch = PipeChannel{Int}(16)\n\n# Producer thread\nproducer = Threads.@spawn begin\n    for i in 1:100\n        put!(ch, i)\n    end\n    close(ch)\nend\n\n# Consumer thread\nconsumer = Threads.@spawn begin\n    for value in ch\n        println(\"Received: \", value)\n    end\nend\n\nwait(producer)\nwait(consumer)","category":"section"},{"location":"#Error-Propagation-with-bind","page":"Home","title":"Error Propagation with bind","text":"Just like Channel, you can bind a task to automatically close the channel and propagate errors:\n\nch = PipeChannel{Int}(16)\n\ntask = @async begin\n    for i in 1:10\n        put!(ch, i)\n    end\n    close(ch)\nend\nbind(ch, task)\n\n# If task fails, the exception propagates to consumers\nfor x in ch\n    println(x)\nend","category":"section"},{"location":"#Thread-Safety","page":"Home","title":"Thread Safety","text":"warning: Single Producer, Single Consumer\nPipeChannel is designed for exactly one producer thread and one consumer thread. Using multiple producers or multiple consumers will cause data races and undefined behavior.\n\nThis constraint enables the lock-free implementation that provides zero-allocation performance.","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"Pages = [\"api.md\"]","category":"section"}]
}
